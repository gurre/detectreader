package detectreader

import (
	"bytes"
	"testing"
)

func TestValidCompression(t *testing.T) {
	data := [][]byte{
		{0x42, 0x5A, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x42, 0x5A, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		// Empty file compressed with Xz
		{0xfd, 0x37, 0x7a, 0x58, 0x5a, 0x00, 0x00, 0x04, 0xe6, 0xd6, 0xb4, 0x46, 0x00, 0x00, 0x00, 0x00, 0x1c, 0xdf, 0x44, 0x21, 0x1f, 0xb6, 0xf3, 0x7d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x04, 0x59, 0x5a},
	}
	for _, b := range data {
		stream := bytes.NewReader(b)
		if _, err := Decompress(stream); err != nil {
			t.Fatalf("Valid stream returned error(%s) for %v", err, b)
		}
	}
}

func TestInvalidCompression(t *testing.T) {
	data := [][]byte{
		// Zip is not yet supported
		{0x50, 0x4b, 0x03, 0x04},
		{0x50, 0x4b, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{},
		{0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	}
	for _, b := range data {
		stream := bytes.NewReader(b)
		if _, err := Decompress(stream); err == nil {
			t.Fatalf("Invalid stream did not return error(%s) for %v", err, b)
		}
	}
}

func TestUncompressed(t *testing.T) {
	data := [][]byte{
		{0xc3, 0xb2, 0xa1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x11, 0xb2, 0x3c, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x2a, 0x32, 0xea, 0x7d, 0xd5, 0x25, 0x59, 0xc5, 0x94, 0xa8, 0xd8, 0xce, 0xc0, 0x4d, 0xaf, 0xe1, 0x43, 0xaf, 0x1c, 0x0d},
		{0x2a, 0x32, 0xea, 0x7d, 0xd5, 0x25, 0x59, 0xc5, 0x94, 0xa8, 0xd8, 0xce, 0xc0, 0x4d, 0xaf, 0xe1, 0x43, 0xaf, 0x1c, 0x0d, 0x2a, 0x32, 0xea, 0x7d, 0xd5, 0x25, 0x59, 0xc5, 0x94, 0xa8, 0xd8, 0xce, 0xc0, 0x4d},
		{0x2a, 0x32, 0xea, 0x7d, 0xd5, 0x25, 0x59, 0xc5, 0x94, 0xa8, 0xd8, 0xce, 0xc0, 0x4d, 0xaf, 0xe1, 0x43, 0xaf, 0x1c, 0x0d, 0x2a, 0x32, 0xea, 0x7d, 0xd5, 0x25, 0x59, 0xc5, 0x94, 0xa8, 0xd8, 0xce, 0xc0, 0x4d},
	}
	for _, b := range data {
		stream := bytes.NewReader(b)
		if _, err := Decompress(stream); err != nil {
			t.Fatalf("Uncompressed stream did return error(%s) for %v", err, b)
		}
	}
}

func TestExtension(t *testing.T) {
	var c Compression

	c = Uncompressed
	if c.Extension() != "" {
		t.Fatalf("Wrong extension for Uncompressed")
	}
	c = Bzip2
	if c.Extension() != ".bz2" {
		t.Fatalf("Wrong extension for Bzip2")
	}
	c = Gzip
	if c.Extension() != ".gz" {
		t.Fatalf("Wrong extension for Gzip")
	}
	c = Xz
	if c.Extension() != ".xz" {
		t.Fatalf("Wrong extension for Xz")
	}
	c = 999
	if c.Extension() != "[unknown]" {
		t.Fatalf("Wrong extension for [unknown]")
	}
}
